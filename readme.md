# Readme

 
**Resetme** - это web сервис, который позволяет пользователям самостоятельно "сбрасывать" пароли в AD, даже когда срок действия пароля уже истёк или пользователь вообще забыл свой пароль.

Сервис требует ввода "капчи", для защиты от ботов, а также проводит верификацию и подтверждение личности пользователя с посмощью отправки смс сообщений на мобильный телефон пользователя, который указан в атрибуте mobile пользователя, в AD.

  

**P.S. Для нормальной работы resetme, Вы должны иметь доменную учётную запись с правами на сброс паролей пользователей в AD. Не следует добавлять учётную запись в группу администраторов домена или Account Operators. Вместо этого можно делигировать права на сброс паролей для пользователей в определенном OU**

  ## Подготовительные работы

### Делегирование прав для учетной записи в Microsoft Windows:
pass

  

## Установка

В качестве окружения lxc контейнер с образом Debian 11 bullseye (5.15.83-1)/Debian 12 bookworm (6.8.4-3). В других ОС и средах виртуализации/контейнеризации не тестировался.


База данных postgresql. Кэш пользовательских сессий redis.

Django установлен с помощью pip, т.к. в репозитории debian версия сильно старше.

### Скрипт автоматической установки

В процессе разработки

### Установка вручную

xargs apt -y install < requirements_apt

pip install -r requirements_pip --break-system-packages



**Будьте внимательны, без опции `--break-system-packages` установка не будет успешна. Нам рекомендуют создать виртуальную среду Python, но поскольку мы уже в виртуальной среде на уровне ОС, игнорируем это требование.**

Создаем директорию, в которой будет расположен проект

`mkdir /resetme`

### Samples

В папке `samples` "лежат" образцы файлов конфигураций для таких программ как nginx, gunicorn(systemd units)

Скопируйте их в соответствующие папки:

`- cp /resetme/samples/gunicorn.* /etc/systemd/system/`
`- cp /resetme/samples/nginx_resetme /etc/nginx/sites-available/nginx_resetme`
`- cp /resetme/samples/redis.conf /etc/redis/redis.conf`
`useradd -M -r -U -s /usr/sbin/nologin gunicorn`
`chown -R www-data:gunicorn /var/log/gunicorn`
`chmod -R g+w /var/log/gunicorn`
`ln -s /etc/nginx/sites-available/nginx_resetme /etc/nginx/sites-enabled/nginx_resetme`

**Добавьте данные из файла `nginx.conf` в секцию http основного конфигурационного файла nginx**
**В файле `/etc/nginx/sites-available/nginx_resetme` измените url сайта, укажите адрес локальной подсети для доступа к /admin**

  Создаем БД, пользователя и назначаем права доступа:

`su - postgres`
`psql`
`CREATE DATABASE resetme_db;`
`CREATE USER resetme_user WITH PASSWORD 'your_password_here';`
`ALTER ROLE resetme_user SET client_encoding TO 'utf8';`
`ALTER ROLE resetme_user SET default_transaction_isolation TO 'read committed';`
`ALTER ROLE resetme_user SET timezone TO 'UTC';`
`GRANT ALL PRIVILEGES ON DATABASE resetme_db TO resetme_user;`
`ALTER DATABASE resetme_db OWNER TO resetme_user;`
`\q`

  
  Добавляем в автозапуск и запускаем службы:

`systemctl daemon-reload && systemctl enable --now gunicorn.service gunicorn.socket nginx redis-server`

  
  

## Описание конфигурационных файлов

В проекте есть файлы vars.py и secret.py, которые хранят в себе переменные и логины/пароли.

### secret.py (в репозитории есть samples/secret_sample.py, который необходимо перенести на уровень выше и переименовать)

- secret_key_django - ключ django сервера, который перенесён из settings.py
- resetme_db_host = 'ip адрес хоста БД, например, localhost'
- resetme_db_port = 'если порт стандартный, можно оставить пустым'
- resetme_db = 'имя БД'
- resetme_db_user = 'имя пользователя БД'
- resetme_db_pass = 'пароль пользователя БД'

Данные для подключения к сервису отправки смс сообщений. Resetme рассчитан на работу с провайдером smsc.ru средствами API через HTTPS GET запросы

- sms_login = 'логин'
- sms_password = 'пароль'

  
### vars.py (в репозитории есть samples/vars_sample.py, который необходимо перенести на уровень выше и переименовать)

Переменная `site_url` содержит полный url, по которому осуществляется переход на сайт. Она используется в коде, чтобы запретить прямой переход на страницы верификации, смены пароля и т.д. Также измените `ALLOWED_HOSTS` в `webapp/webapp/settings.py`

  Переменная `company_name` - имя Вашей организации. Оно будет расположено в нижнем левом углу каждой страницы сайта.

В переменных `background_color_*` указаны цвета фона в шестнадцатеричном коде цветов для каждой страницы сервиса. Обратите внимание, `#` в начале и `;` обязательны. Например,

background_color_index = '#1d1f10;'
background_color_domain_choice = '#005773;'
background_color_verify_phone = '#4d2637;'
background_color_change_password = '#006c73;'
background_color_success = '#00735b;'

Переменная `title_name` содержит название вкладки в браузере.

Переменная `dc_time_sync` хранит значение в минутах. Это время, которое необходимо Вашим контролерам домена, чтобы завершить синхронизацию. Также это время будет показано пользователю на финишной странице сайта.

`login_validator` и `sms_code_validator` - это регулярные выражения для проверки введенных в соответствующие формы данных.

**Если меняете параметры в `vars.py` необходим перезапуск web сервера `systemctl restart gunicorn`**

Чтобы указать кол-во неудачных попыток ввода имени пользователя/"капчи", после которых сессия пользователя будет "сброшена" средствами django, измените значения этой переменной. По умолчанию 3
- count_of_fails_form_threshold = 3

Чтобы указать кол-во неудачных попыток ввода смс кода, после которых сессия пользователя будет "сброшена" средствами django, измените значения этой переменной. По умолчанию 3

- count_of_fails_code_threshold = 3

В нижеуказанных переменных значения для "хэширования" и "соли" введённых паролей пользователей. Это сделано для хранения и отслеживания "истории паролей". Если Вы не знаете, что менять, оставьте значения по умолчанию.

urandom_bytes = 16
algoritm = 'sha256'
coding = 'utf-8'
iter = 100000
dklen = 128

**P.S. при изменении значений на рабочей БД, необходимо вручную очистить таблицу "resetme_user" базы данных от всех значений, т.к. сервис не сможет проверить хэш.**

Следующая переменная, это словарь, в котором указаны критерии сложности пароля. Они проверяются функцией `re.findall`. Их количество жёстко задано, поэтому нельзя увеличивать/уменьшать количество ключей в словаре.

- len: пароль должен быть не короче указанной длины
- upper: пароль должен включать заглавные буквы
- lower: пароль должен включать строчные буквы
- number: пароль должен включать wbahs
- history: указываем, какое количество записей будет хранится в БД, для обеспечения работы "истории паролей"

**Обратите внимание, что чем больше значение этой переменной, тем дольше будет проверять функция. Это скажется на времени ожидания web страницы пользователем**

- change_per_day: разрешенное количество изменений пароля для одного пользователя в сутки

conditions = {'len': 8, 'upper': '[A-Z]', 'lower': '[a-z]', 'number': '[0-9]', 'history': 10, 'change_per_day': 1}

Сервис Resetme использует redis, для хранения некоторых временных данных. Ниже приведены основные настройки.

- redis_host = 'localhost'
- redis_port = 6379
- db = 0
- redis_ttl = это таймаут нахождения пользователя на одной странице. После истечения указанного значения, сессия пользователя будет "сброшена" средствами django и пользователю придётся начать всю процедуру с первой страницы. По умолчанию 600
- redis_ttl_sms_code = это время, в течении которого валиден смс код, который был отправлен пользователю. По умолчанию 120
  

**P.S. Данные о сессиях пользователей хранятся в кэше redis, поэтому нет необходимости настраивать удаление этих данных из БД.**

 

# Сообщения об ошибках/коды возврата:

### Для пользователя:

- Замечена подозрительная активность с участием вашего аккаунта. обратитесь в отдел ИТ для изменения пароля - пользователь пытается сбросить пароль более, чем значение ключа `change_per_day'`в словаре `conditions`, в файле `vars.py`, в сутки.

- Введенные пароли не совпадают! - пользователь ввёл разные пароли в поля пароль и подтверждение пароля

  

### Внутренние коды возврата или сообщения об ошибках:

Возврат из функции check_user():

- 0 - OK
- 1 - пользователь не существует в каталоге LDAP или отключен
- 2 - некоторые поля атрибутов пользователя в каталоге LDAP не заполенны или заполнены не корректно

  
  

### Если подключаться к каталогу ldaps с самоподписным сертификатом, то необходимо:

- сконвертировать сертификат в формат .crt Если сертификат был экспортирован из среды MS CA в формате .cer, то команда следующая: `openssl x509 -inform der -in /путь до вашего сертификата -out new.crt`

- скопировать сертификат CA в формате .crt в директорию cp new.crt /usr/local/share/ca-certificates/new.crt

- update-ca-certificates

- в файле конфигурации /etc/ldap/ldap.conf (если он отсутствует, то: установить пакет `libldap-common` или создать файл вручную)

	- TLS_REQCERT demand
	- TLS_CACERT /etc/ssl/certs/ca-certificates.crt

  
Для проверки работы ldaps:

`openssl s_client -connect dc1.test.local:636` , где dc1.test.local - fqdn вашего сервера с каталогом LDAP

`ldapsearch -H ldaps://dc1.test.local -D 'CN=user,OU=test,OU=test2,DC=test,DC=local' -w password -b 'OU=unit,OU=unnit2,DC=test,DC=local' -d 5 sAMAccountName`, где значение ключа -D это расположение пользователя, под которым подключаетесь к LDAPs, -w пароль этого пользователя, -b подразделение, в котором ищете, -d уровень debug, sAMAccountName - атрибут, который ищете

Соединение должно пройти без ошибок, связанных с TLS. Вы должны увидеть данные, которые запросили в каталоге LDAP

  

### Статические файлы

При изменении статических файлов(css, js, img ect) необходимо выполнить команду `python3 manage.py collectstatic` и перезапустить сервис nginx `systemctl restart nginx`

  
  

# Перед началом работы

  

-  ### Разместите ssl сертификаты в соответствующей директории и настройте `nginx` на корректную работу с ними
-  ### Измените значения переменных в файле `secret.py`
-  ### Измените значения переменных в файле `vars.py`, учитывая ваши индивидуальные требования.
	- Выберите цвет фона. Остальную стилизацию, если она необходима, можно делать средствами CSS, в файле webapp/staticfiles/css/main.css (рядом лежат файлы bootstrap)

  

-  ### Загрузите собственные файлы логотипов в формате `svg` в папку webapp/resetme/static/images

	- favicon.svg - миниатюра иконки на вкладке браузера (width="120" height="120")
	- logo1.svg - логотип компании в верхнем левом углу (не более чем width="200px" height="200px")
	- logo2.svg - логотип компании в нижнем левом углу (не более чем width="200px" height="200px")
  - выполнить команду `python3 manage.py collectstatic`

-  ### Зайдите по url адресу вашего сайта resetme в панель администратора (например, https://resetme.example.ru/admin). В разделе Resetme - Domains нажмите Add, чтобы добавить данные доменов. Их кол-во ничем не ограничено.

	- ad_server: ip address или FQDN вашего контролера домена, например, `ldaps://dc.domain.test:636`
	- base_dn: OU, в котором расположены пользователи, которым будет доступна функция сброса пароля, через данный сервис, например, `OU=Users,DC=domain,DC=test`
	- retrieve_attributes: список с атрибутами мобильного телефона и имени пользователя в AD, например, `mobile,givenName`
	- search_filter: LDAP фильтр, для поиска пользователей в каталоге. По умолчанию ищем только активных пользователей, у которых указан e-mail и мобильный телефон, согласно регулярному выражению. С помощью фильтра "!(memberOf:1.2.840.113556.1.4.1941:=" указываем dn группы Администраторов домена, чтобы невозможно было сбросить им пароль через сервис. Если данный функционал Вам не нужен, то удалите этот фильтр. Например, `(&(sAMAccountName={})(objectCategory=person)(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(mail=*@example.ru)(mobile=+7*)(!(memberOf:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=example,DC=ru)))`
	- admin_username: логин учётной записи с правами на "сброс" паролей пользователей
	- admin_password: пароль учётной записи с правами на "сброс" паролей пользователей